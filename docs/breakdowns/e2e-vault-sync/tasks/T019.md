# T015 - Route Handler Tests for Pull Mode Filtering

**Type**: BE-TEST
**State**: pending
**Phase**: Phase D - Tests

## Business Summary
Test mode filtering for both pull endpoints, ensuring encrypted/plaintext isolation.

## Logic
Test suite covering: correct mode filtering, pagination, empty results for both plaintext and encrypted pull.

## Technical Logic

### New File: `__tests__/api/sync/plaintext/pull.test.ts`

```typescript
import { GET } from '@/app/api/sync/plaintext/pull/route';
import { query } from '@/lib/db';

jest.mock('@clerk/nextjs/server');
jest.mock('@/lib/db');

describe('GET /api/sync/plaintext/pull', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('mode filtering', () => {
    it('should only return encrypted=false records', async () => {
      // Mock mixed records: some encrypted, some plaintext
      (query as jest.Mock).mockResolvedValueOnce([
        [
          { record_id: '1', record_type: 'bookmark', data: {}, version: 1, encrypted: false, deleted: false },
          { record_id: '2', record_type: 'bookmark', data: {}, version: 1, encrypted: true, deleted: false }, // Should be filtered
          { record_id: '3', record_type: 'space', data: {}, version: 1, encrypted: false, deleted: false },
        ]
      ]);

      const request = new Request(`http://localhost/api/sync/plaintext/pull?limit=100`);
      const response = await GET(request);
      const result = await response.json();

      expect(response.ok).toBe(true);
      expect(result.records).toHaveLength(2); // Only plaintext records
      expect(result.records.every((r: any) => !r.ciphertext)).toBe(true);
    });

    it('should filter by encrypted=false in WHERE clause', async () => {
      await GET(new Request(`http://localhost/api/sync/plaintext/pull`));

      expect(query).toHaveBeenCalledWith(
        expect.stringContaining('encrypted = false'),
        expect.any(Array)
      );
    });
  });

  describe('pagination', () => {
    it('should return correct nextCursor when hasMore=true', async () => {
      (query as jest.Mock).mockResolvedValueOnce([
        Array(100).fill(null).map((_, i) => ({
          record_id: `id-${i}`,
          record_type: 'bookmark',
          data: {},
          version: 1,
          encrypted: false,
          deleted: false,
        }))
      ]);

      const response = await GET(new Request(`http://localhost/api/sync/plaintext/pull?limit=50`));
      const result = await response.json();

      expect(result.hasMore).toBe(true);
      expect(result.nextCursor).toBeTruthy();
    });

    it('should return hasMore=false on last page', async () => {
      (query as jest.Mock).mockResolvedValueOnce([[/* less than limit */]]);
      const response = await GET(new Request(`http://localhost/api/sync/plaintext/pull`));
      const result = await response.json();

      expect(result.hasMore).toBe(false);
      expect(result.nextCursor).toBeNull();
    });
  });

  describe('empty results', () => {
    it('should return empty array when no records', async () => {
      (query as jest.Mock).mockResolvedValueOnce([[]]);
      const response = await GET(new Request(`http://localhost/api/sync/plaintext/pull`));
      const result = await response.json();

      expect(result.records).toEqual([]);
      expect(result.hasMore).toBe(false);
    });
  });
});
```

### New File: `__tests__/api/sync/pull.test.ts`

```typescript
import { GET } from '@/app/api/sync/pull/route';

// Similar structure for encrypted pull

describe('GET /api/sync/pull', () => {
  describe('mode filtering', () => {
    it('should only return encrypted=true records', async () => {
      // Mock mixed records
      (query as jest.Mock).mockResolvedValueOnce([
        [
          { record_id: '1', record_type: 'bookmark', ciphertext: Buffer.from('enc1'), version: 1, encrypted: true },
          { record_id: '2', record_type: 'bookmark', ciphertext: Buffer.from('enc2'), version: 1, encrypted: true },
          // Plaintext records should not be in response
        ]
      ]);

      const response = await GET(new Request(`http://localhost/api/sync/pull`));
      const result = await response.json();

      expect(result.records.every((r: any) => r.ciphertext)).toBe(true);
      expect(result.records.every((r: any) => !r.data)).toBe(true);
    });

    it('should filter by encrypted=true in WHERE clause', async () => {
      await GET(new Request(`http://localhost/api/sync/pull`));

      expect(query).toHaveBeenCalledWith(
        expect.stringContaining('encrypted = true'),
        expect.any(Array)
      );
    });
  });
});
```

## Testing
Backend tests (self-referential):
1. Run `npm test` or `jest`
2. All tests pass
3. Coverage shows mode filtering is enforced

## Files
- **Create**: `__tests__/api/sync/plaintext/pull.test.ts`
- **Create**: `__tests__/api/sync/pull.test.ts`

## Patterns
- Reference T018 test structure
- Use jest.mock for database
- Test both success and edge cases

## Dependencies
- T005, T006 must be implemented first

## Notes
These tests verify T005 and T006 fixes are working correctly.
