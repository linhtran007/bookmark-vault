# T011 - Detect Leftover Encrypted Cloud Data in Plaintext Mode

**Type**: FE
**State**: pending
**Phase**: Phase C - Plaintext Mode Blocking (Decision A)

## Business Summary
Check for leftover encrypted records before allowing plaintext sync, preventing data corruption from mixed modes.

## Logic
Before plaintext push/pull, call `POST /api/vault/disable` with `{ action: 'verify' }` (no passphrase). The current server implementation already returns `encryptedRecordCount` for the signed-in user.


## Technical Logic

### Changes Required

**In `hooks/useSyncEngineUnified.ts`**:

```typescript
// Add state for blocked condition
const [isBlocked, setIsBlocked] = useState(false);

// Add function to check for encrypted records
const checkEncryptedRecords = useCallback(async (): Promise<boolean> => {
  if (syncMode !== 'plaintext') return false;

  try {
    const response = await fetch('/api/sync/has-encrypted');
    if (!response.ok) return false;
    const data = await response.json();
    return data.hasEncrypted === true;
  } catch {
    return false;
  }
}, [syncMode]);

// Update syncPush to check before sync
const syncPush = useCallback(async (): Promise<SyncPushResult> => {
  // ... existing canSync check ...

  // NEW: Check for encrypted records in plaintext mode
  if (syncMode === 'plaintext') {
    const hasEncrypted = await checkEncryptedRecords();
    if (hasEncrypted) {
      setIsBlocked(true);
      toast.error('Sync blocked', {
        description: 'Encrypted cloud data exists. Please resolve to continue.'
      });
      return { success: false, synced: 0, conflicts: [], errors: ['Sync blocked by encrypted data'] };
    }
  }

  // ... rest of existing push logic ...
}, [canSync, syncMode, checkEncryptedRecords, /* existing deps */]);

// Update syncPull similarly
const syncPull = useCallback(async (): Promise<PlaintextRecord[]> => {
  // ... existing canSync check ...

  // NEW: Check for encrypted records in plaintext mode
  if (syncMode === 'plaintext') {
    const hasEncrypted = await checkEncryptedRecords();
    if (hasEncrypted) {
      setIsBlocked(true);
      toast.error('Sync blocked', {
        description: 'Encrypted cloud data exists. Please resolve to continue.'
      });
      return [];
    }
  }

  // ... rest of existing pull logic ...
}, [canSync, syncMode, checkEncryptedRecords, /* existing deps */]);

// Expose blocked state
return {
  ...state,
  canSync: canSync(),
  isBlocked, // NEW
  syncPush,
  syncPull,
  // ... rest ...
};
```

## Testing
Backend test:
1. Mock fetch to return `{hasEncrypted: true}`
2. Mock `syncMode = 'plaintext'`
3. Call `syncPush()`
4. Verify `isBlocked = true`
5. Verify error returned

## Files
- **Modify**: `hooks/useSyncEngineUnified.ts`

## Patterns
- Reference T007 for detection endpoint
- Follow existing async check patterns

## Dependencies
- T007 (detection endpoint must exist)

## Notes
This triggers T017 (showing the blocked dialog). The dialog provides actions to resolve the block.
