# T016 - Client Unit Tests for E2E Pull/Apply Utilities

**Type**: BE-TEST
**State**: pending
**Phase**: Phase D - Tests

## Business Summary
Test encrypted pull, storage, and decrypt/apply flow, ensuring end-to-end sync works correctly.

## Logic
Test suite covering: pull returns records, encrypted storage save/load, decryption and apply logic.

## Technical Logic

### New File: `__tests__/lib/sync-engine.test.ts`

```typescript
import { syncPush, syncPull, queueOperation } from '@/lib/sync-engine';

// Mock fetch and localStorage
global.fetch = jest.fn();
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; },
  };
})();

Object.defineProperty(global, 'localStorage', { value: localStorageMock });

describe('lib/sync-engine', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.clear();
  });

  describe('syncPull', () => {
    it('should return pulled records', async () => {
      // Mock fetch to return test records
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          records: [
            { recordId: '1', ciphertext: 'enc1', version: 1, deleted: false, updatedAt: '2024-01-01' },
            { recordId: '2', ciphertext: 'enc2', version: 1, deleted: false, updatedAt: '2024-01-01' },
          ],
          nextCursor: null,
          hasMore: false,
        }),
      });

      const result = await syncPull();

      expect(result.success).toBe(true);
      expect(result.records).toHaveLength(2);
      expect(result.records[0].recordId).toBe('1');
    });

    it('should handle pagination', async () => {
      // First page
      (global.fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({
            records: Array(100).fill(null).map((_, i) => ({
              recordId: `id-${i}`,
              ciphertext: `enc-${i}`,
              version: 1,
              deleted: false,
              updatedAt: '2024-01-01',
            })),
            nextCursor: 'cursor-1',
            hasMore: true,
          }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({
            records: [{ recordId: 'last', ciphertext: 'last-enc', version: 1, deleted: false, updatedAt: '2024-01-01' }],
            nextCursor: null,
            hasMore: false,
          }),
        });

      const result = await syncPull();

      expect(result.records).toHaveLength(101); // 100 + 1
      expect(global.fetch).toHaveBeenCalledTimes(2);
    });

    it('should handle fetch errors', async () => {
      (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));

      const result = await syncPull();

      expect(result.success).toBe(false);
      expect(result.error).toBeTruthy();
    });
  });

  describe('syncPush', () => {
    it('should push operations and clear outbox', async () => {
      // Queue some operations
      queueOperation({ recordId: '1', baseVersion: 0, ciphertext: 'enc1', deleted: false });

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true, results: [{ recordId: '1', version: 1 }], synced: 1 }),
      });

      const result = await syncPush();

      expect(result.success).toBe(true);
      expect(result.pushed).toBe(1);
    });

    it('should handle conflicts', async () => {
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        status: 409,
        ok: false,
        json: async () => ({
          conflicts: [{ recordId: '1', currentVersion: 5 }],
        }),
      });

      const result = await syncPush();

      expect(result.success).toBe(false);
      expect(result.conflicts).toHaveLength(1);
    });
  });
});
```

### New File: `__tests__/lib/encrypted-storage.test.ts`

```typescript
import { saveEncryptedRecords, getEncryptedRecords, clearEncryptedRecords, mergeEncryptedRecords } from '@/lib/encrypted-storage';

const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; },
  };
})();

Object.defineProperty(global, 'localStorage', { value: localStorageMock });

describe('lib/encrypted-storage', () => {
  beforeEach(() => {
    localStorageMock.clear();
  });

  describe('save/get', () => {
    it('should save and retrieve records', () => {
      const records = [
        { recordId: '1', recordType: 'bookmark', ciphertext: 'enc1', version: 1, deleted: false, updatedAt: '2024-01-01' },
      ];

      saveEncryptedRecords(records);
      const retrieved = getEncryptedRecords();

      expect(retrieved).toEqual(records);
    });

    it('should return empty array when no records', () => {
      const retrieved = getEncryptedRecords();
      expect(retrieved).toEqual([]);
    });

    it('should handle localStorage errors gracefully', () => {
      // Mock getItem to throw
      const original = localStorageMock.getItem;
      localStorageMock.getItem = () => { throw new Error('Storage error'); };

      const retrieved = getEncryptedRecords();
      expect(retrieved).toEqual([]);

      localStorageMock.getItem = original;
    });
  });

  describe('clear', () => {
    it('should clear records', () => {
      saveEncryptedRecords([{ recordId: '1', recordType: 'bookmark', ciphertext: 'enc1', version: 1, deleted: false, updatedAt: '2024-01-01' }]);
      clearEncryptedRecords();

      const retrieved = getEncryptedRecords();
      expect(retrieved).toEqual([]);
    });
  });

  describe('merge', () => {
    it('should merge records keeping highest version', () => {
      const existing = [
        { recordId: '1', recordType: 'bookmark', ciphertext: 'enc-v1', version: 1, deleted: false, updatedAt: '2024-01-01' },
        { recordId: '2', recordType: 'bookmark', ciphertext: 'enc2', version: 1, deleted: false, updatedAt: '2024-01-01' },
      ];
      saveEncryptedRecords(existing);

      const newRecords = [
        { recordId: '1', recordType: 'bookmark', ciphertext: 'enc-v2', version: 2, deleted: false, updatedAt: '2024-01-02' },
        { recordId: '3', recordType: 'bookmark', ciphertext: 'enc3', version: 1, deleted: false, updatedAt: '2024-01-01' },
      ];
      mergeEncryptedRecords(newRecords);

      const merged = getEncryptedRecords();
      expect(merged.find(r => r.recordId === '1')?.version).toBe(2); // Updated
      expect(merged.find(r => r.recordId === '2')?.version).toBe(1); // Kept
      expect(merged.find(r => r.recordId === '3')?.version).toBe(1); // Added
    });
  });
});
```

### New File: `__tests__/lib/decrypt-and-apply.test.ts`

```typescript
import { decryptAndApplyRecords } from '@/lib/decrypt-and-apply';
import { saveEncryptedRecords, clearEncryptedRecords } from '@/lib/encrypted-storage';
import { setBookmarks, getBookmarks } from '@/lib/storage';

// Mock dependencies
jest.mock('@/lib/crypto', () => ({
  decryptData: jest.fn(async (ciphertext: string, key: string) => {
    return JSON.stringify({ title: 'Decrypted', url: 'http://test.com', id: ciphertext });
  }),
}));

jest.mock('@/lib/storage');
jest.mock('@/lib/spacesStorage');
jest.mock('@/lib/pinnedViewsStorage');

describe('lib/decrypt-and-apply', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    clearEncryptedRecords();
  });

  it('should decrypt and apply bookmark records', async () => {
    const encryptedRecords = [
      { recordId: '1', recordType: 'bookmark', ciphertext: 'enc1', version: 1, deleted: false, updatedAt: '2024-01-01' },
    ];
    saveEncryptedRecords(encryptedRecords);

    const result = await decryptAndApplyRecords('test-key');

    expect(result.success).toBe(true);
    expect(result.applied).toBe(1);
    expect(setBookmarks).toHaveBeenCalled();
  });

  it('should handle deleted records', async () => {
    const encryptedRecords = [
      { recordId: '1', recordType: 'bookmark', ciphertext: 'enc1', version: 1, deleted: true, updatedAt: '2024-01-01' },
    ];
    saveEncryptedRecords(encryptedRecords);

    // Mock existing bookmarks
    (getBookmarks as jest.Mock).mockReturnValue([{ id: '1', title: 'Old' }]);

    const result = await decryptAndApplyRecords('test-key');

    expect(result.success).toBe(true);
    // Deleted record should be removed, not added
    expect(setBookmarks).toHaveBeenCalledWith([]);
  });

  it('should return empty result when no records', async () => {
    const result = await decryptAndApplyRecords('test-key');

    expect(result.success).toBe(true);
    expect(result.applied).toBe(0);
  });

  it('should handle decryption errors', async () => {
    const encryptedRecords = [
      { recordId: '1', recordType: 'bookmark', ciphertext: 'enc1', version: 1, deleted: false, updatedAt: '2024-01-01' },
    ];
    saveEncryptedRecords(encryptedRecords);

    // Mock decryption failure
    const { decryptData } = require('@/lib/crypto');
    decryptData.mockRejectedValueOnce(new Error('Decryption failed'));

    const result = await decryptAndApplyRecords('test-key');

    expect(result.success).toBe(false);
    expect(result.errors).toHaveLength(1);
    expect(result.errors[0]).toContain('Failed to decrypt record 1');
  });
});
```

## Testing
Backend tests (self-referential):
1. Run `npm test` or `jest`
2. All tests pass
3. Coverage shows >80% for sync engine, storage, and decrypt/apply

## Files
- **Create**: `__tests__/lib/sync-engine.test.ts`
- **Create**: `__tests__/lib/encrypted-storage.test.ts`
- **Create**: `__tests__/lib/decrypt-and-apply.test.ts`

## Patterns
- Reference T018 test structure
- Mock localStorage and fetch
- Test success, error, and edge cases

## Dependencies
- T008-T012 must be implemented first

## Notes
These tests verify the complete pull → store → decrypt → apply flow works correctly.
